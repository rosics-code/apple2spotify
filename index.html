<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Apple2Spotify</title>
<style>
Â  body { font-family: sans-serif; max-width: 800px; margin: auto; padding: 20px; }
Â  h1 { text-align: center; }
Â  input[type=text] { width: 100%; padding: 8px; margin: 5px 0; }
Â  button { padding: 10px 15px; margin: 5px 0; }
Â  #trackList { max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-top: 10px; }
Â  .track { display: flex; align-items: center; margin-bottom: 5px; }
Â  .track label { flex: 1; cursor: pointer; }
</style>
</head>
<body>
<h1>Apple Music â†’ Spotify Transfer</h1>

<label>
Â  Apple Music Public Playlist URL:
Â  <input type="text" id="appleUrl" placeholder="https://music.apple.com/...">
</label>

<label>
Â  Spotify Playlist Name:
Â  <input type="text" id="spotifyPlaylistName" placeholder="My Transferred Playlist">
</label>

<button id="spotifyLogin">Login to Spotify</button>
<button id="fetchApple">Fetch Tracks</button>
<button id="transfer" disabled>Transfer Selected Tracks</button>

<div id="trackList"></div>
<pre id="log"></pre>

<script>
// NOTE: Ensure this REDIRECT_URI is set EXACTLY on your Spotify App Dashboard.
const SPOTIFY_CLIENT_ID = "52dbb7368d80433194dc029bf4f71137";
const REDIRECT_URI = "https://rosics-code.github.io/apple2spotify/index.html";
let spotifyToken = localStorage.getItem("spotify_access_token");
let spotifyUserId = null;
let appleTracks = [];

const log = msg => document.getElementById("log").textContent += msg + "\n";

// Helper to update the UI after login
const updateLoginUI = (isLoggedIn, userName) => {
    const loginButton = document.getElementById("spotifyLogin");
    if (isLoggedIn) {
        loginButton.style.display = 'none';
        log(`âœ… Spotify logged in as: ${userName || 'User'}`);
        document.getElementById("transfer").disabled = false;
    } else {
        loginButton.style.display = 'block';
        document.getElementById("transfer").disabled = true;
    }
};

// PKCE helpers
function base64urlencode(buffer) {
Â  const bytes = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;
Â  return btoa(String.fromCharCode.apply(null, bytes))
Â  Â  .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

async function sha256(buffer) {
Â  return await crypto.subtle.digest("SHA-256", new TextEncoder().encode(buffer));
}

// Generate PKCE code verifier and challenge
async function generatePKCE() {
Â  const verifier = Array.from(crypto.getRandomValues(new Uint8Array(64)))
Â  Â  .map(c => ('00' + c.toString(16)).slice(-2)).join("");
Â  const challenge = base64urlencode(await sha256(verifier));
Â  return { verifier, challenge };
}

// Spotify login with PKCE
document.getElementById("spotifyLogin").onclick = async () => {
Â  const { verifier, challenge } = await generatePKCE();
Â  sessionStorage.setItem("pkce_verifier", verifier);

Â  // Added user-read-private scope which is required for the /me endpointÂ 
Â  const scopes = "playlist-modify-private playlist-modify-public user-read-private";Â 
Â Â 
Â  // FIXED ENDPOINT: Use the real Spotify authorize endpoint
Â  const authUrl = new URL("https://accounts.spotify.com/authorize"); 
Â  authUrl.searchParams.append('response_type', 'code');
Â  authUrl.searchParams.append('client_id', SPOTIFY_CLIENT_ID);
Â  authUrl.searchParams.append('scope', scopes);
Â  authUrl.searchParams.append('redirect_uri', REDIRECT_URI);
Â  authUrl.searchParams.append('code_challenge_method', 'S256');
Â  authUrl.searchParams.append('code_challenge', challenge);
Â Â 
Â  window.location.href = authUrl.toString();
};

// Exchange code for access token
async function exchangeCodeForToken(code) {
Â  const verifier = sessionStorage.getItem("pkce_verifier");
Â Â 
Â  const body = new URLSearchParams({
Â  Â  client_id: SPOTIFY_CLIENT_ID,
Â  Â  grant_type: "authorization_code",
Â  Â  code,
Â  Â  redirect_uri: REDIRECT_URI,
Â  Â  code_verifier: verifier
Â  });

Â  try {
Â  Â  // FIXED ENDPOINT: Use the real Spotify token endpoint
Â  Â  const resp = await fetch("https://accounts.spotify.com/api/token", {
Â  Â  Â  method: "POST",
Â  Â  Â  headers: { "Content-Type": "application/x-www-form-urlencoded" },
Â  Â  Â  body: body.toString()
Â  Â  });
Â  Â Â 
Â  Â  const data = await resp.json();
Â  Â  spotifyToken = data.access_token;
Â  Â Â 
Â  Â  if (spotifyToken) {
        localStorage.setItem("spotify_access_token", spotifyToken);
Â  Â  Â  // Validate token and get user ID
Â  Â  Â  // FIXED ENDPOINT: Use the real Spotify /me endpoint
Â  Â  Â  const userResp = await fetch("https://api.spotify.com/v1/me", { headers: { Authorization: "Bearer " + spotifyToken } });
Â  Â  Â  if (!userResp.ok) throw new Error("Failed to fetch user data.");

Â  Â  Â  const userData = await userResp.json();
Â  Â  Â  spotifyUserId = userData.id;
Â  Â  Â  updateLoginUI(true, userData.display_name || spotifyUserId);
Â  Â  } else {
Â  Â  Â  log("âŒ Failed to get access token: " + (data.error_description || data.error || "Unknown error"));
Â  Â  }
Â  } catch (e) {
Â  Â  log(`âŒ Token Exchange Error: ${e.message}`);
Â  }
}

// Function to validate and set token from local storage
async function checkStoredToken() {
    if (spotifyToken) {
        try {
            // FIXED ENDPOINT: Use the real Spotify /me endpoint
            const userResp = await fetch("https://api.spotify.com/v1/me", { headers: { Authorization: "Bearer " + spotifyToken } });
            if (userResp.ok) {
                const userData = await userResp.json();
                spotifyUserId = userData.id;
                updateLoginUI(true, userData.display_name || spotifyUserId);
                return;
            } else {
                // Token is likely expired, clear it
                localStorage.removeItem("spotify_access_token");
                spotifyToken = null;
            }
        } catch (e) {
            log(`âŒ Stored Token Check Failed: ${e.message}`);
            localStorage.removeItem("spotify_access_token");
            spotifyToken = null;
        }
    }
    updateLoginUI(false);
}

// On page load, check for code in URL or token in storage
window.onload = () => {
Â  const urlParams = new URLSearchParams(window.location.search);
Â  const code = urlParams.get("code");
Â  if (code) {
Â  Â  // remove code from URL
Â  Â  window.history.replaceState({}, document.title, REDIRECT_URI);
Â  Â  exchangeCodeForToken(code);
Â  } else {
        checkStoredToken();
    }
};

// Fetch Apple Music tracks - FINAL ROBUST FIX
document.getElementById("fetchApple").onclick = async () => {
    const appleUrl = document.getElementById("appleUrl").value.trim();
    if (!appleUrl) { log("âŒ Enter Apple Music URL"); return; }

    log("ğŸ”„ Bypassing CORS with corsproxy.io...");

    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(appleUrl)}`;

    try {
        const proxyResp = await fetch(proxyUrl);
        const text = await proxyResp.text();
        
        if (!proxyResp.ok) {
            throw new Error(`Proxy status: ${proxyResp.status} - ${text}`);
        }

        let jsonData = null;
        
        // 1. Get ALL script tags' content
        const scriptMatches = [...text.matchAll(/<script[^>]*>([\s\S]+?)<\/script>/g)];
        let rawJsonText = null;

        for (const match of scriptMatches) {
            const content = match[1];
            // Check for the unique strings that signify the main data payload
            if (content.includes('"type":"playlists"') && content.includes('"relationships":')) {
                rawJsonText = content;
                break;
            }
        }

        if (rawJsonText) {
            // 2. Isolate the JSON object from the surrounding JS code
            let start = rawJsonText.indexOf('{');
            let end = rawJsonText.lastIndexOf('}');
            
            if (start !== -1 && end !== -1 && end > start) {
                let cleanJsonText = rawJsonText.substring(start, end + 1).trim();
                // Remove any trailing semicolon if it exists
                if (cleanJsonText.endsWith(';')) cleanJsonText = cleanJsonText.slice(0, -1);
                
                try {
                    jsonData = JSON.parse(cleanJsonText);
                } catch (e) {
                    log(`âŒ Error parsing isolated JSON: ${e.message}`);
                    return;
                }
            }
        }
        
        if (!jsonData) {
            log("âŒ Playlist data not found in HTML source. Check URL and privacy settings again!");
            return;
        }

        let tempTracks = [];
        
        // 3. Recursive function to dive into the complex JSON structure and pull out songs.
        const extractTracks = (data) => {
            if (!data || typeof data !== 'object') return;

            // Handle arrays (list of playlist/album/song items)
            if (Array.isArray(data)) {
                data.forEach(item => extractTracks(item));
                return;
            }
            
            // If the item has a 'data' property, check inside it
            if (data.data) {
                extractTracks(data.data);
                return;
            }

            // Check for a playlist or album item with track relationships
            if ((data.type === "playlists" || data.type === "albums") && data.relationships && data.relationships.tracks && data.relationships.tracks.data) {
                data.relationships.tracks.data.forEach(song => {
                    if (song.type === "songs" && song.attributes) {
                        tempTracks.push({name: song.attributes.name, artist: song.attributes.artistName});
                    }
                });
            }

            // Check if the item itself is a song object (for albums or single track pages)
            if (data.type === "songs" && data.attributes) {
                tempTracks.push({name: data.attributes.name, artist: data.attributes.artistName});
            }
        };

        // 4. Start extraction based on the likely JSON root structure (it could be a dictionary or a single object)
        if (jsonData && typeof jsonData === 'object' && !jsonData.data) {
            // Shoebox-store format (dictionary of items)
            for (const key in jsonData) {
                extractTracks(jsonData[key]);
            }
        } else {
            // Single object format (like the INITIAL_STATE or a direct API response style)
            extractTracks(jsonData);
        }

        // De-dupe the tracks
        appleTracks = Array.from(new Set(tempTracks.map(t => `${t.name}|${t.artist}`))).map(str => {
            const [name, artist] = str.split('|');
            return { name, artist };
        });

        log(`âœ… Found ${appleTracks.length} unique tracks! Ready for transfer.`);

        const trackListDiv = document.getElementById("trackList");
        trackListDiv.innerHTML = "";
        appleTracks.forEach((t, i) => {
            const div = document.createElement("div");
            div.className = "track";
            div.innerHTML = `<input type="checkbox" id="track${i}" checked><label for="track${i}">${t.name} â€” ${t.artist}</label>`;
            trackListDiv.appendChild(div);
        });

        document.getElementById("transfer").disabled = !spotifyToken;
    } catch(e) {
        log(`âŒ Error fetching Apple Music playlist: ${e.message}. Double-check the URL!`);
    }
};

// Transfer selected tracks to Spotify
document.getElementById("transfer").onclick = async () => {
Â  if (!spotifyToken || !spotifyUserId) { log("âŒ Login to Spotify first!"); return; }
Â  const selectedTracks = appleTracks.filter((t, i) => document.getElementById(`track${i}`).checked);
Â  if (!selectedTracks.length) { log("âŒ No tracks selected"); return; }

Â  const playlistName = document.getElementById("spotifyPlaylistName").value.trim() || "Apple Music Transfer";

Â  try {
Â  Â  // Create Playlist
Â  Â  // FIXED ENDPOINT: Use the real Spotify playlists endpoint
Â  Â  const createResp = await fetch(`https://api.spotify.com/v1/users/${spotifyUserId}/playlists`, {
Â  Â  Â  method: "POST",
Â  Â  Â  headers: { Authorization: `Bearer ${spotifyToken}`, "Content-Type": "application/json" },
Â  Â  Â  body: JSON.stringify({ name: playlistName, public: false })
Â  Â  });
Â  Â  const newPlaylist = await createResp.json();
Â  Â  log("âœ… Created Spotify playlist: " + newPlaylist.name);

Â  Â  const uris = [];
Â  Â  // Search for Tracks
Â  Â  // FIXED ENDPOINT: Use the real Spotify search endpoint
Â  Â  for (const t of selectedTracks) {
Â  Â  Â  const query = encodeURIComponent(`track:${t.name} artist:${t.artist}`); // Better search query
Â  Â  Â  const searchResp = await fetch(`https://api.spotify.com/v1/search?q=${query}&type=track&limit=1`, { headers: { Authorization: "Bearer " + spotifyToken } });
Â  Â  Â  const data = await searchResp.json();
Â  Â  Â  if (data.tracks.items.length) {
Â  Â  Â  Â  uris.push(data.tracks.items[0].uri);
Â  Â  Â  Â  log("Matched: " + t.name);
Â  Â  Â  } else {
Â  Â  Â  Â  log("Not found: " + t.name);
Â  Â  Â  }
Â  Â  }

Â  Â  log(`Found ${uris.length} Spotify matches. Adding to playlist...`);

Â  Â  // Add Tracks in Batches
Â  Â  // FIXED ENDPOINT: Use the real Spotify add tracks endpoint
Â  Â  for (let i = 0; i < uris.length; i += 100) {
Â  Â  Â  const chunk = uris.slice(i, i + 100);
Â  Â  Â  await fetch(`https://api.spotify.com/v1/playlists/${newPlaylist.id}/tracks`, {
Â  Â  Â  Â  method: "POST",
Â  Â  Â  Â  headers: { Authorization: `Bearer ${spotifyToken}`, "Content-Type": "application/json" },
Â  Â  Â  Â  body: JSON.stringify({ uris: chunk })
Â  Â  Â  });
Â  Â  }
Â  Â  log("ğŸ‰ Transfer complete! Check Spotify.");
Â  } catch (e) {
Â  Â  log("âŒ Error during transfer: " + e.message);
Â  }
};
</script>
</body>
</html>
