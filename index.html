<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Apple2Spotify</title>
<style>
  body { font-family: sans-serif; max-width: 800px; margin: auto; padding: 20px; }
  h1 { text-align: center; }
  input[type=text] { width: 100%; padding: 8px; margin: 5px 0; }
  button { padding: 10px 15px; margin: 5px 0; }
  #trackList { max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-top: 10px; }
  .track { display: flex; align-items: center; margin-bottom: 5px; }
  .track label { flex: 1; cursor: pointer; }
</style>
</head>
<body>
<h1>Apple Music → Spotify Transfer (PAGINATION MODE)</h1>

<p><strong>🚨 NEW METHOD:</strong> Paste your **first JSON response** using the first button, then **scroll the playlist** and paste the subsequent paginated responses using the **'Append More JSON'** button.</p>

<label>
  Spotify Playlist Name:
  <input type="text" id="spotifyPlaylistName" placeholder="My Transferred Playlist">
</label>

<button id="spotifyLogin">Login to Spotify</button>
<button id="fetchAppleInitial">1. PASTE INITIAL JSON & START</button>
<button id="fetchAppleAppend" disabled>1b. APPEND MORE JSON</button>
<button id="transfer" disabled>2. Transfer Selected Tracks</button>

<div id="trackList"></div>
<pre id="log"></pre>

<script>
// NOTE: Ensure this REDIRECT_URI is set EXACTLY on your Spotify App Dashboard.
const SPOTIFY_CLIENT_ID = "52dbb7368d80433194dc029bf4f71137";
const REDIRECT_URI = "https://rosics-code.github.io/apple2spotify/index.html";
let spotifyToken = localStorage.getItem("spotify_access_token");
let spotifyUserId = null;
let appleTracks = [];

// Global storage for consolidating all data
let allArtists = {};
let allSongs = {};
let allTrackReferences = [];

const log = msg => document.getElementById("log").textContent += msg + "\n";
const clearLog = () => document.getElementById("log").textContent = "";

// Helper to update the UI after login (Untouched)
const updateLoginUI = (isLoggedIn, userName) => {
    const loginButton = document.getElementById("spotifyLogin");
    if (isLoggedIn) {
        loginButton.style.display = 'none';
        log(`✅ Spotify logged in as: ${userName || 'User'}`);
        document.getElementById("transfer").disabled = false;
    } else {
        loginButton.style.display = 'block';
        document.getElementById("transfer").disabled = true;
    }
};

// PKCE/Spotify Auth functions (Untouched for brevity, assume they are correct)
function base64urlencode(buffer) {
  const bytes = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;
  return btoa(String.fromCharCode.apply(null, bytes))
    .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

async function sha256(buffer) {
  return await crypto.subtle.digest("SHA-256", new TextEncoder().encode(buffer));
}

async function generatePKCE() {
  const verifier = Array.from(crypto.getRandomValues(new Uint8Array(64)))
    .map(c => ('00' + c.toString(16)).slice(-2)).join("");
  const challenge = base64urlencode(await sha256(verifier));
  return { verifier, challenge };
}

document.getElementById("spotifyLogin").onclick = async () => {
  const { verifier, challenge } = await generatePKCE();
  sessionStorage.setItem("pkce_verifier", verifier);

  const scopes = "playlist-modify-private playlist-modify-public user-read-private"; 
  
  const authUrl = new URL("https://accounts.spotify.com/authorize"); 
  authUrl.searchParams.append('response_type', 'code');
  authUrl.searchParams.append('client_id', SPOTIFY_CLIENT_ID);
  authUrl.searchParams.append('scope', scopes);
  authUrl.searchParams.append('redirect_uri', REDIRECT_URI);
  authUrl.searchParams.append('code_challenge_method', 'S256');
  authUrl.searchParams.append('code_challenge', challenge);
  
  window.location.href = authUrl.toString();
};

async function exchangeCodeForToken(code) {
  const verifier = sessionStorage.getItem("pkce_verifier");
  
  const body = new URLSearchParams({
    client_id: SPOTIFY_CLIENT_ID,
    grant_type: "authorization_code",
    code,
    redirect_uri: REDIRECT_URI,
    code_verifier: verifier
  });

  try {
    const resp = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: body.toString()
    });
    
    const data = await resp.json();
    spotifyToken = data.access_token;
    
    if (spotifyToken) {
        localStorage.setItem("spotify_access_token", spotifyToken);
      const userResp = await fetch("https://api.spotify.com/v1/me", { headers: { Authorization: "Bearer " + spotifyToken } });
      if (!userResp.ok) throw new Error("Failed to fetch user data.");

      const userData = await userResp.json();
      spotifyUserId = userData.id;
      updateLoginUI(true, userData.display_name || spotifyUserId);
    } else {
      log("❌ Failed to get access token: " + (data.error_description || data.error || "Unknown error"));
    }
  } catch (e) {
    log(`❌ Token Exchange Error: ${e.message}`);
  }
}

async function checkStoredToken() {
    if (spotifyToken) {
        try {
            const userResp = await fetch("https://api.spotify.com/v1/me", { headers: { Authorization: "Bearer " + spotifyToken } });
            if (userResp.ok) {
                const userData = await userResp.json();
                spotifyUserId = userData.id;
                updateLoginUI(true, userData.display_name || spotifyUserId);
                return;
            } else {
                localStorage.removeItem("spotify_access_token");
                spotifyToken = null;
            }
        } catch (e) {
            log(`❌ Stored Token Check Failed: ${e.message}`);
            localStorage.removeItem("spotify_access_token");
            spotifyToken = null;
        }
    }
    updateLoginUI(false);
}

window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const code = urlParams.get("code");
  if (code) {
    window.history.replaceState({}, document.title, REDIRECT_URI);
    exchangeCodeForToken(code);
  } else {
        checkStoredToken();
    }
};


// CORE PARSING LOGIC (Handles one JSON paste at a time)
const parseAppleJson = (rawJsonString, isInitial) => {
    
    // Clear global stores on initial run only
    if (isInitial) {
        allArtists = {};
        allSongs = {};
        allTrackReferences = [];
        clearLog();
    }

    log(`Processing JSON data chunk... (Initial: ${isInitial})`);

    try {
        let jsonData;
        try {
            jsonData = JSON.parse(rawJsonString);
        } catch (e) {
            log(`❌ Error: Failed to parse the pasted content as JSON. ${e.message}`);
            return false;
        }
        
        // ===============================================
        // PASS 1: Create lookup maps from the 'resources' and 'included' sections
        // ===============================================
        let artistsAdded = 0;
        let songsAdded = 0;

        // Helper to process a list of resources (songs/artists)
        const processResources = (resourceList) => {
            if (!resourceList) return;
            
            resourceList.forEach(resource => {
                if (resource.type === 'artists' && resource.attributes && resource.attributes.name) {
                    if (!allArtists[resource.id]) {
                        allArtists[resource.id] = resource.attributes.name;
                        artistsAdded++;
                    }
                } else if ((resource.type === 'songs' || resource.type === 'music-videos') && resource.attributes && resource.attributes.name) {
                    if (!allSongs[resource.id]) {
                        // Collect full song details, including artist relationships
                        allSongs[resource.id] = {
                            name: resource.attributes.name,
                            artistData: resource.relationships && resource.relationships.artists ? resource.relationships.artists.data : null
                        };
                        songsAdded++;
                    }
                }
            });
        };

        // Check for top-level resources key
        if (jsonData.resources) {
            for (const type in jsonData.resources) {
                if (typeof jsonData.resources[type] === 'object' && !Array.isArray(jsonData.resources[type])) {
                    processResources(Object.values(jsonData.resources[type])); 
                }
            }
        }

        // Check for top-level included key 
        if (jsonData.included) {
            processResources(jsonData.included);
        }
        
        log(`🔍 New Data MUSHED: ${artistsAdded} artists | ${songsAdded} full songs.`);
        
        // ===============================================
        // PASS 2: Extract track references from the main playlist data 
        // ===============================================
        let referencesAdded = 0;

        // Recursive function to find the core track data array references
        const findTrackReferences = (data) => {
            if (!data || typeof data !== 'object') return;
            if (Array.isArray(data)) {
                data.forEach(item => findTrackReferences(item));
                return;
            }

            // Target the playlist tracks relationship
            if (data.relationships && data.relationships.tracks && data.relationships.tracks.data) {
                data.relationships.tracks.data.forEach(trackRef => {
                    // Check if the track reference is already in our list
                    if ((trackRef.type === 'songs' || trackRef.type === 'music-videos') && !allTrackReferences.find(r => r.id === trackRef.id)) {
                        allTrackReferences.push(trackRef);
                        referencesAdded++;
                    }
                });
                return;
            }
            
            // Recurse through all properties
            for (const key in data) {
                 if (typeof data[key] === 'object') {
                    findTrackReferences(data[key]);
                }
            }
        };

        findTrackReferences(jsonData.data);
        log(`🔍 References added: ${referencesAdded} (Total: ${allTrackReferences.length}).`);
        
        return true; // Successfully parsed
    } catch(e) {
        log(`❌ A major error occurred during parsing: ${e.message}`);
        return false;
    }
};


// Function to finalize the data, map names, and update UI
const finalizeTracks = () => {
    let tempTracks = [];

    // Combine track info
    allTrackReferences.forEach(trackRef => {
        const songData = allSongs[trackRef.id];
        
        if (songData) {
            let primaryArtistName = 'Unknown Artist';
            
            // Get the artist ID from the song data's relationships
            if (songData.artistData && songData.artistData.length > 0) {
                const primaryArtistId = songData.artistData[0].id;
                primaryArtistName = allArtists[primaryArtistId] || primaryArtistName;
            }
            
            const name = songData.name;
            const artist = primaryArtistName;

            if (name && name !== 'undefined' && artist !== 'Unknown Artist') {
                tempTracks.push({name, artist});
            }
        }
    });

    // De-dupe the tracks
    appleTracks = Array.from(new Set(tempTracks.map(t => `${t.name}|${t.artist}`))).map(str => {
        const [name, artist] = str.split('|');
        return { name, artist };
    });

    if (appleTracks.length === 0) {
        log("❌ Zero unique, valid tracks found. Try pasting more JSON data by scrolling your playlist.");
        return;
    }

    log(`\n🎉 Final Check: Found ${appleTracks.length} unique tracks! Ready for transfer.`);

    const trackListDiv = document.getElementById("trackList");
    trackListDiv.innerHTML = "";
    appleTracks.forEach((t, i) => {
        const div = document.createElement("div");
        div.className = "track";
        div.innerHTML = `<input type="checkbox" id="track${i}" checked><label for="track${i}">${t.name} — ${t.artist}</label>`;
        trackListDiv.appendChild(div);
    });

    document.getElementById("transfer").disabled = !spotifyToken;
};

// Event handlers for the two paste buttons
document.getElementById("fetchAppleInitial").onclick = () => {
    const rawJsonString = prompt("PASTE THE FIRST (OFFSET=0) FULL JSON RESPONSE HERE:");
    if (!rawJsonString) { return; }
    
    if (parseAppleJson(rawJsonString, true)) {
        document.getElementById("fetchAppleAppend").disabled = false;
        finalizeTracks();
    }
};

document.getElementById("fetchAppleAppend").onclick = () => {
    const rawJsonString = prompt("PASTE THE NEXT PAGINATION JSON RESPONSE HERE:");
    if (!rawJsonString) { return; }
    
    if (parseAppleJson(rawJsonString, false)) {
        finalizeTracks();
    }
};


// Transfer selected tracks to Spotify (Untouched)
document.getElementById("transfer").onclick = async () => {
  if (!spotifyToken || !spotifyUserId) { log("❌ Login to Spotify first!"); return; }
  const selectedTracks = appleTracks.filter((t, i) => document.getElementById(`track${i}`).checked);
  if (!selectedTracks.length) { log("❌ No tracks selected"); return; }

  const playlistName = document.getElementById("spotifyPlaylistName").value.trim() || "Apple Music Transfer";

  try {
    const createResp = await fetch(`https://api.spotify.com/v1/users/${spotifyUserId}/playlists`, {
      method: "POST",
      headers: { Authorization: `Bearer ${spotifyToken}`, "Content-Type": "application/json" },
      body: JSON.stringify({ name: playlistName, public: false })
    });
    const newPlaylist = await createResp.json();
    log("✅ Created Spotify playlist: " + newPlaylist.name);

    const uris = [];
    for (const t of selectedTracks) {
      const query = encodeURIComponent(`track:${t.name} artist:${t.artist}`);
      const searchResp = await fetch(`https://api.spotify.com/v1/search?q=${query}&type=track&limit=1`, { headers: { Authorization: "Bearer " + spotifyToken } });
      const data = await searchResp.json();
      if (data.tracks.items.length) {
        uris.push(data.tracks.items[0].uri);
        log("Matched: " + t.name);
      } else {
        log("Not found: " + t.name);
      }
    }

    log(`Found ${uris.length} Spotify matches. Adding to playlist...`);

    for (let i = 0; i < uris.length; i += 100) {
      const chunk = uris.slice(i, i + 100);
      await fetch(`https://api.spotify.com/v1/playlists/${newPlaylist.id}/tracks`, {
        method: "POST",
        headers: { Authorization: `Bearer ${spotifyToken}`, "Content-Type": "application/json" },
        body: JSON.stringify({ uris: chunk })
      });
    }
    log("🎉 Transfer complete! Check Spotify.");
  } catch (e) {
    log("❌ Error during transfer: " + e.message);
  }
};
</script>
</body>
</html>
