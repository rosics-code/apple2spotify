<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Apple2Spotify - Hybrid Auth (URI Trimmed)</title>
<style>
/* ... (CSS remains the same) ... */
body { font-family: "Segoe UI", sans-serif; max-width: 900px; margin: auto; padding: 20px; background: #f0f2f5; }
h1 { text-align: center; color: #1DB954; text-shadow: 1px 1px #00000022; }
label { display: block; margin: 10px 0 5px; font-weight: bold; color: #333; }
input[type=text] { width: 100%; padding: 10px; margin-bottom: 10px; border-radius: 5px; border: 1px solid #ccc; }
button { padding: 10px 20px; margin: 5px 5px 15px 0; background: #1DB954; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
button:hover { background: #17a44c; }
#trackList { max-height: 350px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; border-radius: 5px; background: white; margin-top: 10px; }
.track { display: flex; align-items: center; margin-bottom: 5px; }
.track label { flex: 1; cursor: pointer; }

/* Status Indicator Style */
#spotifyStatus{
    margin-top: -10px; 
    margin-bottom: 10px; 
    font-weight: bold; 
    padding: 5px; 
    border-radius: 4px;
    text-align: center;
}
.status-logged-out { background-color: #ffdddd; color: #cc0000; border: 1px solid #cc0000; }
.status-logged-in { background-color: #ddffdd; color: #1DB954; border: 1px solid #1DB954; }

#log { max-height: 200px; overflow-y: auto; background: #222; color: #0f0; padding: 10px; border-radius: 5px; font-family: monospace; margin-top: 10px; }
#progressContainer { width: 100%; background: #ddd; height: 20px; border-radius: 10px; margin-top: 10px; display: none; }
#progressBar { width: 0%; height: 100%; background: #1DB954; border-radius: 10px; transition: width 0.2s; }
</style>
</head>
<body>
<h1>🎵 Apple Music → Spotify Transfer (Hybrid Auth) 🎵</h1>

<label>Apple Music Public Playlist URL:</label>
<input type="text" id="appleUrl" placeholder="https://music.apple.com/...">

<label>Spotify Playlist Name:</label>
<input type="text" id="spotifyPlaylistName" placeholder="My Transferred Playlist">

<div id="spotifyStatus" class="status-logged-out">Spotify: Attempting Auto-Login or Paste Token Below</div>

<label>Current/Manual Spotify Access Token:</label>
<input type="text" id="spotifyTokenInput" placeholder="Token will appear here or paste a new one...">

<button id="setToken">Validate/Set Spotify Token</button>
<button id="fetchApple">Fetch Apple Tracks / Login via Spotify</button>
<button id="transfer" disabled>Transfer Selected Tracks</button>

<div id="trackList"></div>

<div id="progressContainer">
  <div id="progressBar"></div>
</div>

<pre id="log"></pre>

<script src="https://cdn.jsdelivr.net/npm/spotify-web-api-js@1.5.2/src/spotify-web-api.min.js"></script>

<script>
window.onload = async () => {
  // Client ID
  const SPOTIFY_CLIENT_ID = "a1d76286f77e4427896b0ee7f5360595"; 
  
  // 💥 UPDATED REDIRECT URI: Now without /index.html but with a trailing slash!
  const REDIRECT_URI = "https://rosics-code.github.io/apple2spotify/"; 
  
  const SCOPES = "playlist-modify-public playlist-modify-private user-read-private";
  const SPOTIFY_TOKEN_URL = 'https://accounts.spotify.com/api/token'; 

  const spotifyApi = new SpotifyWebApi();
  const logEl = document.getElementById("log");
  const progressContainer = document.getElementById("progressContainer");
  const progressBar = document.getElementById("progressBar");
  const fetchAppleBtn = document.getElementById("fetchApple");
  const transferBtn = document.getElementById("transfer");
  const statusEl = document.getElementById("spotifyStatus");
  const tokenInputEl = document.getElementById("spotifyTokenInput"); 

  const log = msg => {
    logEl.textContent += msg + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  };

  let appleTracks = [];
  let spotifyUserId = null;
  
  const setAuthStatus = (loggedIn, message) => {
      statusEl.textContent = message;
      statusEl.className = loggedIn ? "status-logged-in" : "status-logged-out";
      transferBtn.disabled = !loggedIn;
      document.getElementById("setToken").disabled = false; 
  };
  
  // --- PKCE Utility Functions ---

  const generateRandomString = (length) => {
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const values = window.crypto.getRandomValues(new Uint8Array(length));
    return values.reduce((acc, x) => acc + possible[x % possible.length], "");
  };

  const base64UrlEncode = (input) => {
    return btoa(String.fromCharCode(...new Uint8Array(input)))
      .replace(/=/g, '')
      .replace(/\+/g, '-')
      .replace(/\//g, '_');
  };

  const pkceChallengeFromVerifier = async (v) => {
    const hashed = await window.crypto.subtle.digest('SHA-256', (new TextEncoder()).encode(v));
    return base64UrlEncode(hashed);
  };
  
  // --- PKCE Auth Flow Functions ---

  const redirectToSpotifyAuth = async () => {
    const codeVerifier = generateRandomString(128);
    const codeChallenge = await pkceChallengeFromVerifier(codeVerifier);

    localStorage.setItem('spotify_code_verifier', codeVerifier); 

    const authUrl = new URL('https://accounts.spotify.com/authorize?client_id=$');
    
    authUrl.searchParams.append('client_id', SPOTIFY_CLIENT_ID);
    authUrl.searchParams.append('response_type', 'code');
    authUrl.searchParams.append('redirect_uri', REDIRECT_URI);
    authUrl.searchParams.append('scope', SCOPES);
    authUrl.searchParams.append('code_challenge_method', 'S256');
    authUrl.searchParams.append('code_challenge', codeChallenge);
    
    window.location.href = authUrl.toString();
  };

  const exchangeCodeForToken = async (code) => {
    const codeVerifier = localStorage.getItem('spotify_code_verifier');
    
    if (!codeVerifier) return null;
    
    const params = new URLSearchParams();
    params.append('client_id', SPOTIFY_CLIENT_ID);
    params.append('grant_type', 'authorization_code');
    params.append('code', code);
    params.append('redirect_uri', REDIRECT_URI);
    params.append('code_verifier', codeVerifier);
    
    try {
      const response = await fetch(SPOTIFY_TOKEN_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: params
      });

      if (!response.ok) {
        const errorData = await response.json();
        log(`❌ PKCE Exchange Failed: ${errorData.error_description || errorData.error}`);
        throw new Error(`Token exchange failed. Error: ${errorData.error || response.status}`);
      }
      
      const data = await response.json();
      
      localStorage.setItem('spotify_access_token', data.access_token);
      localStorage.setItem('spotify_refresh_token', data.refresh_token);
      localStorage.removeItem('spotify_code_verifier'); 
      
      return data.access_token;
      
    } catch(e) {
      log("❌ Failed PKCE Code Exchange. Fallback to manual token.");
      return null;
    }
  };
  
  const refreshToken = async () => {
      const refreshTokenValue = localStorage.getItem('spotify_refresh_token');
      if (!refreshTokenValue) return null;

      const params = new URLSearchParams();
      params.append('client_id', SPOTIFY_CLIENT_ID);
      params.append('grant_type', 'refresh_token');
      params.append('refresh_token', refreshTokenValue);

      try {
        const response = await fetch(SPOTIFY_TOKEN_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: params
        });

        if (!response.ok) throw new Error(`Refresh token failed! Status: ${response.status}`);
        
        const data = await response.json();
        
        localStorage.setItem('spotify_access_token', data.access_token);
        if (data.refresh_token) localStorage.setItem('spotify_refresh_token', data.refresh_token);
        
        log("🔄 Access token refreshed.");
        return data.access_token;

      } catch (e) {
        log("❌ Auto-refresh failed. Refresh token deleted.");
        localStorage.removeItem('spotify_access_token');
        localStorage.removeItem('spotify_refresh_token');
        return null;
      }
  };
  
  const validateTokenAndSetUser = async (token) => {
      if (!token) return false;
      spotifyApi.setAccessToken(token);
      tokenInputEl.value = token;
      try {
          const me = await spotifyApi.getMe();
          spotifyUserId = me.id;
          const displayName = me.display_name || spotifyUserId;
          setAuthStatus(true, `Spotify: Logged in as ${displayName} (Token Valid)`);
          log(`✅ Spotify logged in as: ${displayName}`);
          return true;
      } catch (e) {
          log("❌ Token validation failed. Token is expired or invalid.");
          spotifyApi.setAccessToken(null);
          return false;
      }
  };


  // --- Main Auth Setup on Page Load ---
  const setupAuth = async () => {
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    let token = localStorage.getItem('spotify_access_token');

    // 1. Handle PKCE Redirect/Exchange
    if (code) {
      log("✅ Spotify redirect detected. Exchanging code for token...");
      token = await exchangeCodeForToken(code);
      // Clean up the URL query parameters
      window.history.replaceState(null, '', REDIRECT_URI); 
    } 
    
    // 2. Try to refresh existing token
    if (!token && localStorage.getItem('spotify_refresh_token')) {
        token = await refreshToken();
    }
    
    // 3. Validate token or set unauthorized status
    if (token) {
        await validateTokenAndSetUser(token);
    } else {
        setAuthStatus(false, "Spotify: Authorization needed (Click 'Fetch' or paste token)");
        tokenInputEl.value = "";
    }
  };
  
  await setupAuth();


  // --- Event Listeners ---

  // Manual Token Setter/Validator
  document.getElementById("setToken").onclick = async () => {
    const token = tokenInputEl.value.trim();
    if (!token) { 
        log("❌ Enter a Spotify token or use the automatic login button."); 
        setAuthStatus(false, "Spotify: Authorization needed (Click 'Fetch' or paste token)");
        return; 
    }
    await validateTokenAndSetUser(token);
  };
  

  // Fetch Apple Music tracks / Login Trigger
  document.getElementById("fetchApple").onclick = async () => {
    // If not logged in, trigger the PKCE redirect (Step 1 of PKCE)
    if (!spotifyApi.getAccessToken()) {
        log("🔄 Redirecting to Spotify login for authorization...");
        redirectToSpotifyAuth(); 
        return; 
    }
    
    // --- Apple Fetch Logic (from the working version) ---
    const appleUrl = document.getElementById("appleUrl").value.trim();
    if (!appleUrl) { log("❌ Enter Apple Music URL"); return; }

    log("🔄 Fetching Apple Music playlist...");
    try {
      const resp = await fetch(appleUrl);
      const text = await resp.text();
      const jsonMatch = text.match(/<script id="shoebox-store" type="fastboot\/shoebox">(.+?)<\/script>/);
      if (!jsonMatch) { log("❌ Playlist JSON not found"); return; }

      const jsonData = JSON.parse(jsonMatch[1]);
      let tempTracks = []; 
      
      for (const key in jsonData) {
        const items = jsonData[key].data;
        if (!items) continue;
        
        items.forEach(item => {
            if(item.type === "playlists" || item.type === "albums") {
                const songs = item.relationships?.tracks?.data || [];
                songs.forEach(song => {
                    if (song.type === "songs" && song.attributes) {
                        tempTracks.push({name: song.attributes.name, artist: song.attributes.artistName});
                    }
                });
            }
            if (item.type === "songs" && item.attributes) {
                 tempTracks.push({name: item.attributes.name, artist: item.attributes.artistName});
            }
        });
      }

      // De-dupe the tracks
      appleTracks = Array.from(new Set(tempTracks.map(t => `${t.name}|${t.artist}`))).map(str => {
        const [name, artist] = str.split('|');
        return { name, artist };
      });

      log(`✅ Found ${appleTracks.length} unique tracks`);

      const trackListDiv = document.getElementById("trackList");
      trackListDiv.innerHTML = "";
      appleTracks.forEach((t, i) => {
        const div = document.createElement("div");
        div.className = "track";
        div.innerHTML = `<input type="checkbox" id="track${i}" checked><label for="track${i}">${t.name} — ${t.artist}</label>`;
        trackListDiv.appendChild(div);
      });

      document.getElementById("transfer").disabled = false;
    } catch(e) {
      log("❌ Error fetching Apple Music playlist: " + e.message);
    }
  };

  // Transfer selected tracks to Spotify
  document.getElementById("transfer").onclick = async () => {
    if (!spotifyUserId) { log("❌ Log in to Spotify first (Click 'Fetch' or set token manually)."); return; }
    
    // Check if the token might be expired just before transfer
    if (!spotifyApi.getAccessToken()) {
        const newToken = await refreshToken();
        if (newToken) {
             await validateTokenAndSetUser(newToken);
        } else {
             log("❌ Session expired. Please click 'Fetch' to log in again or paste a new token.");
             setAuthStatus(false, "Spotify: Session Expired. Re-Auth Required.");
             return; 
        }
    }

    const selectedTracks = appleTracks.filter((t, i) => document.getElementById(`track${i}`).checked);
    if (!selectedTracks.length) { log("❌ No tracks selected"); return; }

    const playlistName = document.getElementById("spotifyPlaylistName").value.trim() || "Apple Music Transfer";

    try {
      const newPlaylist = await spotifyApi.createPlaylist(spotifyUserId, { name: playlistName, public: false });
      log("✅ Created Spotify playlist: " + newPlaylist.name);

      progressContainer.style.display = "block";
      progressBar.style.width = "0%";

      const uris = [];
      for (let i = 0; i < selectedTracks.length; i++) {
        const t = selectedTracks[i];
        const res = await spotifyApi.searchTracks(`${t.name} ${t.artist}`, { limit: 1 }); 
        
        if (res.tracks.items.length) {
          uris.push(res.tracks.items[0].uri);
          log("Matched: " + t.name);
        } else {
          log("Not found: " + t.name);
        }
        progressBar.style.width = `${Math.round((i+1)/selectedTracks.length*100)}%`;
      }

      log(`Found ${uris.length} Spotify matches. Adding to playlist...`);
      const BATCH_SIZE = 100;
      for (let i = 0; i < uris.length; i += BATCH_SIZE) {
        const chunk = uris.slice(i, i + BATCH_SIZE);
        await spotifyApi.addTracksToPlaylist(newPlaylist.id, chunk);
        log(`Added batch ${Math.ceil((i+1)/100)} of ${Math.ceil(uris.length/100)}`);
      }

      log("🎉 Transfer complete! Check Spotify for your playlist.");
      progressBar.style.width = "100%";
    } catch (e) {
      log("❌ Error during transfer: " + e.message);
      progressContainer.style.display = "none";
    }
  };
};
</script>
</body>
</html>
