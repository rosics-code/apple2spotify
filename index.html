<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Apple2Spotify</title>
<style>
Â  body { font-family: sans-serif; max-width: 800px; margin: auto; padding: 20px; }
Â  h1 { text-align: center; }
Â  input[type=text] { width: 100%; padding: 8px; margin: 5px 0; }
Â  button { padding: 10px 15px; margin: 5px 0; background-color: #ff2d55; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
  button:hover { background-color: #d82447; }
Â  #trackList { max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-top: 10px; border-radius: 4px; background-color: #f7f7f7; }
Â  .track { display: flex; align-items: center; margin-bottom: 5px; }
Â  .track label { flex: 1; cursor: pointer; }
  #log { white-space: pre-wrap; word-break: break-all; background-color: #eee; padding: 10px; border-radius: 4px; margin-top: 15px; }
</style>
</head>
<body>
<h1>Apple Music â†’ Spotify Transfer (ULTRA-VACUUM MODE) ğŸ’…</h1>

<p><strong>âœ¨ THE ONE:</strong> This script will search the **entire JSON** you paste for *any* song or artist data. Find the **biggest** playlist JSON and paste it once.</p>

<label>
Â  Spotify Playlist Name:
Â  <input type="text" id="spotifyPlaylistName" placeholder="My Transferred Playlist">
</label>

<button id="spotifyLogin">Login to Spotify</button>
<button id="fetchApple">1. PASTE JSON & PARSE ALL</button>
<button id="transfer" disabled>2. Transfer Selected Tracks</button>

<div id="trackList"></div>
<pre id="log">Status updates will appear here...</pre>

<script>
// NOTE: Ensure this REDIRECT_URI is set EXACTLY on your Spotify App Dashboard.
const SPOTIFY_CLIENT_ID = "52dbb7368d80433194dc029bf4f71137";
const REDIRECT_URI = "https://rosics-code.github.io/apple2spotify/index.html";
let spotifyToken = localStorage.getItem("spotify_access_token");
let spotifyUserId = null;
let appleTracks = [];

const log = msg => document.getElementById("log").textContent += msg + "\n";
const clearLog = () => document.getElementById("log").textContent = "";

// Helper to update the UI after login (Untouched)
const updateLoginUI = (isLoggedIn, userName) => {
Â  Â  const loginButton = document.getElementById("spotifyLogin");
Â  Â  if (isLoggedIn) {
Â  Â  Â  Â  loginButton.style.display = 'none';
Â  Â  Â  Â  log(`âœ… Spotify logged in as: ${userName || 'User'}`);
Â  Â  Â  Â  document.getElementById("transfer").disabled = false;
Â  Â  } else {
Â  Â  Â  Â  loginButton.style.display = 'block';
Â  Â  Â  Â  document.getElementById("transfer").disabled = true;
Â  Â  }
};

// PKCE/Spotify Auth functions (FIXED Uint8Array)
function base64urlencode(buffer) {
Â  const bytes = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;
Â  return btoa(String.fromCharCode.apply(null, bytes))
Â  Â  .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

async function sha256(buffer) {
Â  return await crypto.subtle.digest("SHA-256", new TextEncoder().encode(buffer));
}

async function generatePKCE() {
Â  // ğŸš¨ FIXED: Corrected Uint8array to Uint8Array
Â  const verifier = Array.from(crypto.getRandomValues(new Uint8Array(64)))Â 
Â  Â  .map(c => ('00' + c.toString(16)).slice(-2)).join("");
Â  const challenge = base64urlencode(await sha256(verifier));
Â  return { verifier, challenge };
}

document.getElementById("spotifyLogin").onclick = async () => {
Â  const { verifier, challenge } = await generatePKCE();
Â  sessionStorage.setItem("pkce_verifier", verifier);

Â  const scopes = "playlist-modify-private playlist-modify-public user-read-private";Â 
Â Â 
Â  const authUrl = new URL("https://accounts.spotify.com/authorize");Â 
Â  authUrl.searchParams.append('response_type', 'code');
Â  authUrl.searchParams.append('client_id', SPOTIFY_CLIENT_ID);
Â  authUrl.searchParams.append('scope', scopes);
Â  authUrl.searchParams.append('redirect_uri', REDIRECT_URI);
Â  authUrl.searchParams.append('code_challenge_method', 'S256');
Â  authUrl.searchParams.append('code_challenge', challenge);
Â Â 
Â  window.location.href = authUrl.toString();
};

async function exchangeCodeForToken(code) {
Â  const verifier = sessionStorage.getItem("pkce_verifier");
Â Â 
Â  const body = new URLSearchParams({
Â  Â  client_id: SPOTIFY_CLIENT_ID,
Â  Â  grant_type: "authorization_code",
Â  Â  code,
Â  Â  redirect_uri: REDIRECT_URI,
Â  Â  code_verifier: verifier
Â  });

Â  try {
Â  Â  const resp = await fetch("https://accounts.spotify.com/api/token", {
Â  Â  Â  method: "POST",
Â  Â  Â  headers: { "Content-Type": "application/x-www-form-urlencoded" },
Â  Â  Â  body: body.toString()
Â  Â  });
Â  Â Â 
Â  Â  const data = await resp.json();
Â  Â  spotifyToken = data.access_token;
Â  Â Â 
Â  Â  if (spotifyToken) {
Â  Â  Â  Â  localStorage.setItem("spotify_access_token", spotifyToken);
Â  Â  Â  const userResp = await fetch("https://api.spotify.com/v1/me", { headers: { Authorization: "Bearer " + spotifyToken } });
Â  Â  Â  if (!userResp.ok) throw new Error("Failed to fetch user data.");

Â  Â  Â  const userData = await userResp.json();
Â  Â  Â  spotifyUserId = userData.id;
Â  Â  Â  updateLoginUI(true, userData.display_name || spotifyUserId);
Â  Â  } else {
Â  Â  Â  log("âŒ Failed to get access token: " + (data.error_description || data.error || "Unknown error"));
Â  Â  }
Â  } catch (e) {
Â  Â  log(`âŒ Token Exchange Error: ${e.message}`);
Â  }
}

async function checkStoredToken() {
Â  Â  if (spotifyToken) {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const userResp = await fetch("https://api.spotify.com/v1/me", { headers: { Authorization: "Bearer " + spotifyToken } });
Â  Â  Â  Â  Â  Â  if (userResp.ok) {
Â  Â  Â  Â  Â  Â  Â  Â  const userData = await userResp.json();
Â  Â  Â  Â  Â  Â  Â  Â  spotifyUserId = userData.id;
Â  Â  Â  Â  Â  Â  Â  Â  updateLoginUI(true, userData.display_name || spotifyUserId);
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  localStorage.removeItem("spotify_access_token");
Â  Â  Â  Â  Â  Â  Â  Â  spotifyToken = null;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  log(`âŒ Stored Token Check Failed: ${e.message}`);
Â  Â  Â  Â  Â  Â  localStorage.removeItem("spotify_access_token");
Â  Â  Â  Â  Â  Â  spotifyToken = null;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  updateLoginUI(false);
}

window.onload = () => {
Â  const urlParams = new URLSearchParams(window.location.search);
Â  const code = urlParams.get("code");
Â  if (code) {
Â  Â  window.history.replaceState({}, document.title, REDIRECT_URI);
Â  Â  exchangeCodeForToken(code);
Â  } else {
Â  Â  Â  Â  checkStoredToken();
Â  Â  }
};


// CORE AGGRESSIVE PARSING LOGIC
const parseAppleJson = (rawJsonString) => {
Â  Â Â 
Â  Â  clearLog();
Â  Â  log("Processing JSON data with the Ultra-Vacuum parser...");

Â  Â  try {
Â  Â  Â  Â  let jsonData;
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  jsonData = JSON.parse(rawJsonString);
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  log(`âŒ Error: Failed to parse the pasted content as JSON. Did you copy the whole response? ${e.message}`);
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Global maps to store unique song and artist data found anywhere
Â  Â  Â  Â  const allArtists = {};
Â  Â  Â  Â  const allSongs = {};
Â  Â  Â  Â  const trackReferences = [];

Â  Â  Â  Â  // Recursive function to search EVERYTHING for songs, artists, and references
Â  Â  Â  Â  const aggressiveSearch = (data) => {
Â  Â  Â  Â  Â  Â  if (!data || typeof data !== 'object') return;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Handle arrays (recursion)
Â  Â  Â  Â  Â  Â  if (Array.isArray(data)) {
Â  Â  Â  Â  Â  Â  Â  Â  data.forEach(item => aggressiveSearch(item));
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- 1. Identify and Store Full Song/Artist Data (Complex JSON: relationships/included) ---
Â  Â  Â  Â  Â  Â  if (data.type === 'artists' && data.attributes && data.attributes.name) {
Â  Â  Â  Â  Â  Â  Â  Â  // Store artist name by ID
Â  Â  Â  Â  Â  Â  Â  Â  allArtists[data.id] = data.attributes.name;
Â  Â  Â  Â  Â  Â  } else if ((data.type === 'songs' || data.type === 'music-videos') && data.attributes) {
Â  Â  Â  Â  Â  Â  Â  Â  // Store full song details by ID if it has a name
Â  Â  Â  Â  Â  Â  Â  Â  if (data.attributes.name) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  allSongs[data.id] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  name: data.attributes.name,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Get artist ID reference, often found in relationships
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  artistData: data.relationships && data.relationships.artists ? data.relationships.artists.data : null
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

            // ğŸ’¥ DUAL-FORMAT LOGIC: DIRECTLY CAPTURE TRACKS (Simple JSON: library-songs or data without relationships)
            // This is the key update to support the simpler API response structure.
            if ((data.type === 'library-songs' || data.type === 'song') && data.id && data.attributes && data.attributes.name && data.attributes.artistName) {
                // Store the reference
                if (!trackReferences.find(r => r.id === data.id)) {
                    trackReferences.push({id: data.id, type: data.type});
                }
                // Store the full details directly to be picked up in the final pass
                allSongs[data.id] = {
                    name: data.attributes.name,
                    artistNameDirect: data.attributes.artistName // Store direct artist name
                };
            }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // --- 2. Identify and Store Playlist Track References ---
Â  Â  Â  Â  Â  Â  // If it's a song/music-video type, it's a reference to a track, even if it's nested
Â  Â  Â  Â  Â  Â  if ((data.type === 'songs' || data.type === 'music-videos') && data.id) {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (!trackReferences.find(r => r.id === data.id)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  trackReferences.push({id: data.id, type: data.type});
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // If it contains a relationships.tracks.data array, grab those references too
Â  Â  Â  Â  Â  Â  Â if (data.relationships && data.relationships.tracks && Array.isArray(data.relationships.tracks.data)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â data.relationships.tracks.data.forEach(ref => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if ((ref.type === 'songs' || ref.type === 'music-videos') && !trackReferences.find(r => r.id === ref.id)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  trackReferences.push(ref);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â });
Â  Â  Â  Â  Â  Â  Â }

Â  Â  Â  Â  Â  Â  // --- 3. Recurse through all object properties (Deep Dive) ---
Â  Â  Â  Â  Â  Â  for (const key in data) {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (typeof data[key] === 'object' && key !== 'attributes') { // Avoid deep diving into simple attribute lists
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  aggressiveSearch(data[key]);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  // Start the search from the top level
Â  Â  Â  Â  aggressiveSearch(jsonData);
Â  Â  Â  Â Â 
Â  Â  Â  Â  log(`ğŸ” Found ${Object.keys(allArtists).length} unique artists.`);
Â  Â  Â  Â  log(`ğŸ” Found ${Object.keys(allSongs).length} unique full songs (with names).`);
Â  Â  Â  Â  log(`ğŸ” Found ${trackReferences.length} track ID references.`);
Â  Â  Â  Â Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ===============================================
Â  Â  Â  Â  // FINAL PASS: Combine references and song data
Â  Â  Â  Â  // ===============================================
Â  Â  Â  Â  let tempTracks = [];

Â  Â  Â  Â  trackReferences.forEach(trackRef => {
Â  Â  Â  Â  Â  Â  const songData = allSongs[trackRef.id];
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (songData) {
Â  Â  Â  Â  Â  Â  Â  Â  let name = songData.name;
                let artist = 'Unknown Artist';
                
                // 1. Check for the direct artist name (from the simple JSON format)
                if (songData.artistNameDirect) {
                    artist = songData.artistNameDirect;
                } 
                // 2. Fallback to relationships/included (from the complex JSON format)
                else if (songData.artistData && songData.artistData.length > 0) {
                    const primaryArtistId = songData.artistData[0].id;
                    artist = allArtists[primaryArtistId] || artist;
                }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (name && name !== 'undefined' && artist !== 'Unknown Artist') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tempTracks.push({name, artist});
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  // De-dupe the tracks
Â  Â  Â  Â  appleTracks = Array.from(new Set(tempTracks.map(t => `${t.name}|${t.artist}`))).map(str => {
Â  Â  Â  Â  Â  Â  const [name, artist] = str.split('|');
Â  Â  Â  Â  Â  Â  return { name, artist };
Â  Â  Â  Â  });

Â  Â  Â  Â  if (appleTracks.length === 0) {
Â  Â  Â  Â  Â  Â  log("âŒ Zero unique, valid tracks found after combining data. Ensure you pasted the main playlist JSON response.");
Â  Â  Â  Â  Â  Â  return true; // Still report true so we don't block
Â  Â  Â  Â  }

Â  Â  Â  Â  log(`\nğŸ‰ Success! Found ${appleTracks.length} unique tracks! Ready for transfer.`);

Â  Â  Â  Â  const trackListDiv = document.getElementById("trackList");
Â  Â  Â  Â  trackListDiv.innerHTML = "";
Â  Â  Â  Â  appleTracks.forEach((t, i) => {
Â  Â  Â  Â  Â  Â  const div = document.createElement("div");
Â  Â  Â  Â  Â  Â  div.className = "track";
Â  Â  Â  Â  Â  Â  div.innerHTML = `<input type="checkbox" id="track${i}" checked><label for="track${i}">${t.name} â€” ${t.artist}</label>`;
Â  Â  Â  Â  Â  Â  trackListDiv.appendChild(div);
Â  Â  Â  Â  });

Â  Â  Â  Â  document.getElementById("transfer").disabled = !spotifyToken;
Â  Â  Â  Â  return true;Â 
Â  Â  } catch(e) {
Â  Â  Â  Â  log(`âŒ A major error occurred during parsing: ${e.message}`);
Â  Â  Â  Â  return false;
Â  Â  }
};

// Event handler for the single paste button
document.getElementById("fetchApple").onclick = () => {
Â  Â  const rawJsonString = prompt("PASTE THE ENTIRE JSON RESPONSE HERE. Choose the largest file from the Network tab that contains your playlist's track list.");
Â  Â  if (!rawJsonString) { return; }
Â  Â Â 
Â  Â  parseAppleJson(rawJsonString);
};


// Transfer selected tracks to Spotify (Untouched)
document.getElementById("transfer").onclick = async () => {
Â  if (!spotifyToken || !spotifyUserId) { log("âŒ Login to Spotify first!"); return; }
Â  const selectedTracks = appleTracks.filter((t, i) => document.getElementById(`track${i}`).checked);
Â  if (!selectedTracks.length) { log("âŒ No tracks selected"); return; }

Â  const playlistName = document.getElementById("spotifyPlaylistName").value.trim() || "Apple Music Transfer";

Â  try {
Â  Â  log(`\nStarting transfer for ${selectedTracks.length} tracks...`);
Â  Â  const createResp = await fetch(`https://api.spotify.com/v1/users/${spotifyUserId}/playlists`, {
Â  Â  Â  method: "POST",
Â  Â  Â  headers: { Authorization: `Bearer ${spotifyToken}`, "Content-Type": "application/json" },
Â  Â  Â  body: JSON.stringify({ name: playlistName, public: false })
Â  Â  });
Â  Â  const newPlaylist = await createResp.json();
Â  Â  if (!newPlaylist.id) throw new Error("Failed to create Spotify playlist.");
Â  Â  log(`âœ… Created Spotify playlist: ${newPlaylist.name} (ID: ${newPlaylist.id})`);

Â  Â  const uris = [];
Â  Â  for (const t of selectedTracks) {
Â  Â  Â  const query = encodeURIComponent(`track:${t.name} artist:${t.artist}`);
Â  Â  Â  const searchResp = await fetch(`https://api.spotify.com/v1/search?q=${query}&type=track&limit=1`, { headers: { Authorization: "Bearer " + spotifyToken } });
Â  Â  Â  const data = await searchResp.json();
Â  Â  Â  if (data.tracks && data.tracks.items.length) {
Â  Â  Â  Â  uris.push(data.tracks.items[0].uri);
Â  Â  Â  Â  // log("Matched: " + t.name); // Too verbose, uncomment if debugging search matches
Â  Â  Â  } else {
Â  Â  Â  Â  log(`Not found: ${t.name} by ${t.artist}`);
Â  Â  Â  }
Â  Â  }

Â  Â  log(`Found ${uris.length} Spotify matches. Adding to playlist...`);

Â  Â  for (let i = 0; i < uris.length; i += 100) {
Â  Â  Â  const chunk = uris.slice(i, i + 100);
Â  Â  Â  await fetch(`https://api.spotify.com/v1/playlists/${newPlaylist.id}/tracks`, {
Â  Â  Â  Â  method: "POST",
Â  Â  Â  Â  headers: { Authorization: `Bearer ${spotifyToken}`, "Content-Type": "application/json" },
Â  Â  Â  Â  body: JSON.stringify({ uris: chunk })
Â  Â  Â  });
Â  Â  }
Â  Â  log(`\nğŸ‰ Transfer complete! Added ${uris.length} tracks to ${newPlaylist.name}. Check Spotify now!`);
Â  } catch (e) {
Â  Â  log("âŒ Error during transfer: " + e.message);
Â  }
};
</script>
</body>
</html>
