<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Apple2Spotify</title>
<style>
  body { font-family: sans-serif; max-width: 800px; margin: auto; padding: 20px; }
  h1 { text-align: center; }
  input[type=text] { width: 100%; padding: 8px; margin: 5px 0; }
  button { padding: 10px 15px; margin: 5px 0; background-color: #ff2d55; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
  button:hover { background-color: #d82447; }
  #trackList { max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-top: 10px; border-radius: 4px; background-color: #f7f7f7; }
  .track { display: flex; align-items: center; margin-bottom: 5px; }
  .track label { flex: 1; cursor: pointer; }
  #log { white-space: pre-wrap; word-break: break-all; background-color: #eee; padding: 10px; border-radius: 4px; margin-top: 15px; }
</style>
</head>
<body>
<h1>Apple Music ‚Üí Spotify Transfer (ULTRA-VACUUM üëë 2.1)</h1>

<p><strong>‚ú® THE UPGRADE:</strong> Now cleaning track names to fix <em>(feat.)</em> and explicit tag issues. Paste your JSON and let's get it! üíÖ</p>

<label>
  Spotify Playlist Name:
  <input type="text" id="spotifyPlaylistName" placeholder="My Transferred Playlist">
</label>

<button id="spotifyLogin">Login to Spotify</button>
<button id="fetchApple">1. PASTE JSON & PARSE ALL</button>
<button id="transfer" disabled>2. Transfer Selected Tracks</button>

<div id="trackList"></div>
<pre id="log">Status updates will appear here...</pre>

<script>
const SPOTIFY_CLIENT_ID = "52dbb7368d80433194dc029bf4f71137";
const REDIRECT_URI = "https://rosics-code.github.io/apple2spotify/index.html";
let spotifyToken = localStorage.getItem("spotify_access_token");
let spotifyUserId = null;
let appleTracks = [];

const log = msg => document.getElementById("log").textContent += msg + "\n";
const clearLog = () => document.getElementById("log").textContent = "";

const updateLoginUI = (isLoggedIn, userName) => {
    const loginButton = document.getElementById("spotifyLogin");
    if (isLoggedIn) {
        loginButton.style.display = 'none';
        log(`‚úÖ Spotify logged in as: ${userName || 'User'}`);
        document.getElementById("transfer").disabled = false;
    } else {
        loginButton.style.display = 'block';
        document.getElementById("transfer").disabled = true;
    }
};

function base64urlencode(buffer) {
  const bytes = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;
  return btoa(String.fromCharCode.apply(null, bytes))
    .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

async function sha256(buffer) {
  return await crypto.subtle.digest("SHA-256", new TextEncoder().encode(buffer));
}

async function generatePKCE() {
  const verifier = Array.from(crypto.getRandomValues(new Uint8Array(64))) 
    .map(c => ('00' + c.toString(16)).slice(-2)).join("");
  const challenge = base64urlencode(await sha256(verifier));
  return { verifier, challenge };
}

document.getElementById("spotifyLogin").onclick = async () => {
  const { verifier, challenge } = await generatePKCE();
  sessionStorage.setItem("pkce_verifier", verifier);
  const scopes = "playlist-modify-private playlist-modify-public user-read-private"; 
  const authUrl = new URL("https://accounts.spotify.com/authorize"); 
  authUrl.searchParams.append('response_type', 'code');
  authUrl.searchParams.append('client_id', SPOTIFY_CLIENT_ID);
  authUrl.searchParams.append('scope', scopes);
  authUrl.searchParams.append('redirect_uri', REDIRECT_URI);
  authUrl.searchParams.append('code_challenge_method', 'S256');
  authUrl.searchParams.append('code_challenge', challenge);
  window.location.href = authUrl.toString();
};

async function exchangeCodeForToken(code) {
  const verifier = sessionStorage.getItem("pkce_verifier");
  const body = new URLSearchParams({
    client_id: SPOTIFY_CLIENT_ID,
    grant_type: "authorization_code",
    code,
    redirect_uri: REDIRECT_URI,
    code_verifier: verifier
  });

  try {
    const resp = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: body.toString()
    });
    const data = await resp.json();
    spotifyToken = data.access_token;
    if (spotifyToken) {
        localStorage.setItem("spotify_access_token", spotifyToken);
        const userResp = await fetch("https://api.spotify.com/v1/me", { headers: { Authorization: "Bearer " + spotifyToken } });
        const userData = await userResp.json();
        spotifyUserId = userData.id;
        updateLoginUI(true, userData.display_name || spotifyUserId);
    }
  } catch (e) { log(`‚ùå Token Exchange Error: ${e.message}`); }
}

async function checkStoredToken() {
    if (spotifyToken) {
        try {
            const userResp = await fetch("https://api.spotify.com/v1/me", { headers: { Authorization: "Bearer " + spotifyToken } });
            if (userResp.ok) {
                const userData = await userResp.json();
                spotifyUserId = userData.id;
                updateLoginUI(true, userData.display_name || spotifyUserId);
                return;
            }
        } catch (e) { localStorage.removeItem("spotify_access_token"); }
    }
    updateLoginUI(false);
}

window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const code = urlParams.get("code");
  if (code) {
    window.history.replaceState({}, document.title, REDIRECT_URI);
    exchangeCodeForToken(code);
  } else { checkStoredToken(); }
};

const parseAppleJson = (rawJsonString) => {
    if (appleTracks.length === 0) clearLog();
    log("Processing JSON data...");
    try {
        let jsonData = JSON.parse(rawJsonString);
        const allArtists = {};
        const allSongs = {};
        const trackReferences = [];
        const existingTrackMap = new Set(appleTracks.map(t => `${t.name}|${t.artist}`));

        const aggressiveSearch = (data) => {
            if (!data || typeof data !== 'object') return;
            if (Array.isArray(data)) { data.forEach(item => aggressiveSearch(item)); return; }

            if (data.type === 'artists' && data.attributes?.name) {
                allArtists[data.id] = data.attributes.name;
            } else if ((data.type === 'songs' || data.type === 'music-videos' || data.type === 'library-songs') && data.attributes?.name) {
                allSongs[data.id] = {
                    name: data.attributes.name,
                    artistNameDirect: data.attributes.artistName || null,
                    artistData: data.relationships?.artists?.data || null
                };
            }
            if ((data.type?.includes('song') || data.type === 'music-videos') && data.id) {
                 if (!trackReferences.find(r => r.id === data.id)) trackReferences.push({id: data.id, type: data.type});
            }
            for (const key in data) { if (typeof data[key] === 'object') aggressiveSearch(data[key]); }
        };

        aggressiveSearch(jsonData);
        let newTracks = [];
        trackReferences.forEach(trackRef => {
            const songData = allSongs[trackRef.id] || (jsonData.resources?.['library-songs']?.[trackRef.id]);
            if (songData) {
                let name = songData.attributes ? songData.attributes.name : songData.name;
                let artist = songData.attributes ? songData.attributes.artistName : (songData.artistNameDirect || 'Unknown Artist');
                
                const uniqueKey = `${name}|${artist}`;
                if (name && !existingTrackMap.has(uniqueKey)) {
                    newTracks.push({name, artist});
                    existingTrackMap.add(uniqueKey);
                }
            }
        });

        appleTracks = appleTracks.concat(newTracks);
        log(`\n‚úÖ Added ${newTracks.length} tracks. Total: ${appleTracks.length}.`);
        
        const trackListDiv = document.getElementById("trackList");
        trackListDiv.innerHTML = "";
        appleTracks.forEach((t, i) => {
            const div = document.createElement("div");
            div.className = "track";
            div.innerHTML = `<input type="checkbox" id="track${i}" checked><label for="track${i}">${t.name} ‚Äî ${t.artist}</label>`;
            trackListDiv.appendChild(div);
        });
        return true; 
    } catch(e) { log(`‚ùå Parsing error: ${e.message}`); return false; }
};

document.getElementById("fetchApple").onclick = () => {
    const rawJsonString = prompt("PASTE JSON HERE:");
    if (rawJsonString) parseAppleJson(rawJsonString);
};

// THE MAGIC FIX FOR FEAT. AND EXPLICIT SONGS
const cleanTrackName = (name) => {
  return name
    .replace(/\(feat\..*?\)/gi, '') // Remove (feat. ...)
    .replace(/\[feat\..*?\]/gi, '') // Remove [feat. ...]
    .replace(/- feat\..*/gi, '')    // Remove - feat...
    .replace(/\(Explicit\)/gi, '')  // Remove Apple's explicit tag if it leaked
    .replace(/\[Explicit\]/gi, '')  // Remove explicit brackets
    .trim();
};

document.getElementById("transfer").onclick = async () => {
  if (!spotifyToken || !spotifyUserId) return;
  const selectedTracks = appleTracks.filter((t, i) => document.getElementById(`track${i}`).checked);
  const playlistName = document.getElementById("spotifyPlaylistName").value.trim() || "Apple Music Transfer";

  try {
    log(`\nStarting transfer for ${selectedTracks.length} tracks...`);
    const createResp = await fetch(`https://api.spotify.com/v1/users/${spotifyUserId}/playlists`, {
      method: "POST",
      headers: { Authorization: `Bearer ${spotifyToken}`, "Content-Type": "application/json" },
      body: JSON.stringify({ name: playlistName, public: false })
    });
    const newPlaylist = await createResp.json();

    const uris = [];
    for (const t of selectedTracks) {
      const cleanName = cleanTrackName(t.name);
      // We search by name and artist but keep it slightly broad to catch explicit versions
      const query = encodeURIComponent(`track:${cleanName} artist:${t.artist}`);
      const searchResp = await fetch(`https://api.spotify.com/v1/search?q=${query}&type=track&limit=5`, { 
          headers: { Authorization: "Bearer " + spotifyToken } 
      });
      const data = await searchResp.json();
      
      if (data.tracks?.items?.length) {
        // Try to find the explicit one first if it exists, otherwise take the first match
        const bestMatch = data.tracks.items.find(item => item.explicit) || data.tracks.items[0];
        uris.push(bestMatch.uri);
      } else {
        log(`‚ùå Not found: ${t.name} by ${t.artist}`);
      }
    }

    for (let i = 0; i < uris.length; i += 100) {
      await fetch(`https://api.spotify.com/v1/playlists/${newPlaylist.id}/tracks`, {
        method: "POST",
        headers: { Authorization: `Bearer ${spotifyToken}`, "Content-Type": "application/json" },
        body: JSON.stringify({ uris: uris.slice(i, i + 100) })
      });
    }
    log(`\nüéâ Done! Added ${uris.length} tracks to ${newPlaylist.name}. Go check YouAreCuteVille's finest playlist!`);
  } catch (e) { log("‚ùå Error: " + e.message); }
};
</script>
</body>
</html>
